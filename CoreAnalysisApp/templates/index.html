<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <!-- 设置字符编码为UTF-8 -->
    <meta charset="UTF-8">
    <!-- 设置视口，使页面在不同设备上能自适应显示 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 设置网页标题 -->
    <title>地质岩心图文分析系统</title>
    <!-- 设置网页图标 -->
    <link rel="icon" href="../static/image/gdou.png" type="image/png">
    <link rel="shortcut icon" href="../image/gdou.png" type="image/png">
    <link rel="apple-touch-icon" href="../image/gdou.png">
    <style>
        /* 全局样式，将所有元素的外边距和内边距设置为0，并使用盒模型 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* 设置body的字体和背景颜色 */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            /* 使用线性渐变作为背景 */
            background: linear-gradient(135deg, #667eea 0%, #a26cda 100%);
            /* 设置最小高度为100vh，确保页面内容至少占满整个屏幕高度 */
            min-height: 100vh;
            /* 设置内边距为20px */
            padding: 20px;
        }

        /* 容器样式，设置最大宽度、居中显示、背景颜色、圆角和阴影 */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            /* 隐藏溢出内容 */
            overflow: hidden;
        }

        /* 头部样式，设置背景颜色、文字颜色、内边距和居中对齐 */
        .header {
            background: linear-gradient(135deg, #e3da73 0%, #508ac5 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        /* 头部图标样式，设置高度、右边距和垂直对齐方式 */
        .header img {
            height: 200px; /* 缩小图标尺寸，适配文字高度 */
            margin-right: 15px; /* 优化图标与文字间距 */
            vertical-align: middle; /* 确保图标与文字基线对齐 */
        }

        /* 头部标题样式，设置字体大小、底部外边距和文字阴影 */
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        /* 头部段落样式，设置字体大小和透明度 */
        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        /* 主要内容区域样式，使用网格布局 */
        .main-content {
            display: grid;
            grid-template-columns: 300px 1fr;
            min-height: 80vh;
        }

        /* 侧边栏样式，设置背景颜色、内边距和右边框 */
        .sidebar {
            background: #f8f9fa;
            padding: 30px;
            border-right: 1px solid #e9ecef;
        }

        /* 控制区域样式，设置底部外边距 */
        .control-section {
            margin-bottom: 30px;
        }

        /* 控制区域标题样式，设置文字颜色、底部外边距、字体大小、底部边框和内边距 */
        .control-section h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.2rem;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }

        /* 文件上传区域样式，设置边框、圆角、内边距、文字居中对齐、背景颜色和过渡效果 */
        .file-upload {
            border: 2px dashed #3498db;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            background: #f8f9fa;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        /* 文件上传区域鼠标悬停样式，改变边框颜色和背景颜色 */
        .file-upload:hover {
            border-color: #2980b9;
            background: #e8f4f8;
        }

        /* 文件上传输入框样式，隐藏输入框 */
        .file-upload input {
            display: none;
        }

        /* 文件上传文字样式，设置文字颜色和字体大小 */
        .file-upload-text {
            color: #666;
            font-size: 0.9rem;
        }

        /* 按钮样式，设置宽度、内边距、外边距、边框、圆角、字体大小、光标样式和过渡效果 */
        .btn {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        /* 主要按钮样式，设置背景颜色和文字颜色 */
        .btn-primary {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }

        /* 主要按钮鼠标悬停样式，向上移动2px并添加阴影 */
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
        }

        /* 成功按钮样式，设置背景颜色和文字颜色 */
        .btn-success {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
            color: white;
        }

        /* 成功按钮鼠标悬停样式，向上移动2px并添加阴影 */
        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(39, 174, 96, 0.3);
        }

        /* 警告按钮样式，设置背景颜色和文字颜色 */
        .btn-warning {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            color: white;
        }

        /* 警告按钮鼠标悬停样式，向上移动2px并添加阴影 */
        .btn-warning:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(243, 156, 18, 0.3);
        }

        /* 信息按钮样式，设置背景颜色和文字颜色 */
        .btn-info {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }

        /* 信息按钮鼠标悬停样式，向上移动2px并添加阴影 */
        .btn-info:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
        }

        /* 禁用按钮样式，设置透明度和光标样式 */
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }

        /* 参数组样式，设置上下外边距 */
        .param-group {
            margin: 15px 0;
        }

        /* 参数组标签样式，设置显示方式、底部外边距、文字颜色和字体粗细 */
        .param-group label {
            display: block;
            margin-bottom: 5px;
            color: #2c3e50;
            font-weight: 500;
        }

        /* 参数组输入框样式，设置宽度、内边距、边框、圆角和字体大小 */
        .param-group input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 0.9rem;
        }

        /* 参数组输入框聚焦样式，改变边框颜色和添加阴影 */
        .param-group input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 5px rgba(52, 152, 219, 0.3);
        }

        /* 内容区域样式，设置内边距 */
        .content-area {
            padding: 30px;
        }

        /* 图像网格样式，使用网格布局 */
        .image-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        /* 图像卡片样式，设置背景颜色、圆角、阴影和过渡效果 */
        .image-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            transition: transform 0.3s ease;
        }

        /* 图像卡片鼠标悬停样式，向上移动5px */
        .image-card:hover {
            transform: translateY(-5px);
        }

        /* 图像卡片标题样式，设置背景颜色、文字颜色、内边距和字体大小 */
        .image-card h4 {
            background: #2c3e50;
            color: white;
            padding: 12px 15px;
            margin: 0;
            font-size: 1rem;
        }

        /* 图像卡片图片样式，设置宽度、高度、适应方式和背景颜色 */
        .image-card img {
            width: 100%;
            height: 250px;
            object-fit: contain;
            background: #f8f9fa;
        }

        /* 结果区域样式，设置背景颜色、圆角、阴影和内边距 */
        .results-section {
            background: white;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            padding: 25px;
            margin-bottom: 20px;
        }

        /* 结果区域标题样式，设置文字颜色、底部外边距和字体大小 */
        .results-section h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        /* 结果项样式，使用弹性布局、两端对齐和底部边框 */
        .result-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }

        /* 最后一个结果项样式，取消底部边框 */
        .result-item:last-child {
            border-bottom: none;
        }

        /* 结果标签样式，设置字体粗细和文字颜色 */
        .result-label {
            font-weight: 500;
            color: #2c3e50;
        }

        /* 结果值样式，设置文字颜色和字体粗细 */
        .result-value {
            color: #27ae60;
            font-weight: 600;
        }

        /* 柱状图区域样式，设置文字居中对齐和顶部外边距 */
        .histogram-section {
            text-align: center;
            margin-top: 20px;
        }

        /* 柱状图图片样式，设置最大宽度、圆角和阴影 */
        .histogram-section img {
            max-width: 100%;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        /* 加载中样式，隐藏元素、文字居中对齐、内边距和文字颜色 */
        .loading {
            display: none;
            text-align: center;
            padding: 40px;
            color: #666;
        }

        /* 加载中动画样式，添加旋转动画 */
        .loading::after {
            content: '';
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }

        /* 旋转动画关键帧 */
        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        /* 提示框样式，设置内边距、上下外边距、圆角和字体粗细 */
        .alert {
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
            font-weight: 500;
        }

        /* 成功提示框样式，设置背景颜色、文字颜色和边框 */
        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        /* 错误提示框样式，设置背景颜色、文字颜色和边框 */
        .alert-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        /* 改进的菜单栏样式，设置背景颜色、内边距、弹性布局、对齐方式、间距和文字颜色 */
        .menu-bar {
            background: linear-gradient(135deg, #e3da73 0%, #508ac5 100%);
            padding: 12px 20px;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            color: white;
            border-bottom: 2px solid #3498db;
        }

        /* 菜单项样式，设置弹性布局、对齐方式、间距、背景颜色、内边距、圆角和过渡效果 */
        .menu-item {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 12px;
            border-radius: 6px;
            transition: background 0.3s ease;
        }

        /* 菜单项鼠标悬停样式，改变背景颜色 */
        .menu-item:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        /* 菜单项标签样式，设置字体粗细和不换行 */
        .menu-item label {
            font-weight: 500;
            white-space: nowrap;
        }

        /* 菜单项复选框样式，设置宽度和高度 */
        .menu-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #3498db;
        }

        /* 菜单项颜色选择器样式，设置宽度、高度、无边框、透明背景和光标样式 */
        .menu-item input[type="color"] {
            width: 30px;
            height: 30px;
            border: none;
            background: transparent;
            cursor: pointer;
        }

        /* 菜单项数字输入框样式，设置宽度、内边距、边框、圆角、背景颜色、文字颜色和居中对齐 */
        .menu-item input[type="number"] {
            width: 60px;
            padding: 5px 8px;
            border: 1px solid #555;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            text-align: center;
        }

        /* 菜单项数字输入框聚焦样式，改变边框颜色 */
        .menu-item input[type="number"]:focus {
            outline: none;
            border-color: #3498db;
        }

        /* 绘图画布容器样式，设置相对定位、隐藏溢出内容、圆角和背景颜色 */
        .canvas-container {
            position: relative;
            overflow: hidden;
            border-radius: 8px;
            background: #f8f9fa;
        }

        /* 绘图画布样式，设置绝对定位、宽度、高度和层级 */
        .drawing-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        /* 禁用选择文本样式 */
        .no-select {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* 媒体查询，当屏幕宽度小于768px时，调整布局 */
        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .image-grid {
                grid-template-columns: 1fr;
            }

            .header h1 {
                font-size: 2rem;
            }

            .menu-bar {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
<!-- 容器元素，包含整个页面内容 -->
<div class="container">
    <!-- 头部区域，显示标题和图标 -->
    <div class="header">
        <!-- 显示图标 -->
        <img src="../static/image/gdou.png" alt="图标">
        <!-- 显示标题 -->
        <h1>地质岩心图文分析系统</h1>
        <!-- 显示副标题 -->
        <p>智能化岩心图像分析与特征提取</p>
    </div>

    <!-- 改进的菜单栏，包含视图模式、画笔模式、画笔颜色和画笔大小的设置 -->
    <div class="menu-bar">
        <!-- 视图模式菜单项 -->
        <div class="menu-item">
            <label for="viewSwitch">视图模式</label>
            <input type="checkbox" id="viewSwitch" class="no-select">
        </div>
        <!-- 画笔模式菜单项 -->
        <div class="menu-item">
            <label for="brushSwitch">画笔模式</label>
            <input type="checkbox" id="brushSwitch" class="no-select">
        </div>
        <!-- 画笔颜色菜单项 -->
        <div class="menu-item">
            <label for="brushColor">画笔颜色</label>
            <input type="color" id="brushColor" value="#ff0000" class="no-select">
        </div>
        <!-- 画笔大小菜单项 -->
        <div class="menu-item">
            <label for="brushSize">画笔大小</label>
            <input type="number" id="brushSize" value="5" min="1" max="50" class="no-select">
        </div>
    </div>

    <!-- 主要内容区域，包含侧边栏和内容区域 -->
    <div class="main-content">
        <!-- 侧边栏，包含文件上传、分析参数设置和导出按钮 -->
        <div class="sidebar">
            <!-- 文件上传区域 -->
            <div class="control-section">
                <!-- 显示文件上传标题 -->
                <h3>图像上传</h3>
                <!-- 文件上传区域，点击时触发文件选择框 -->
                <div class="file-upload" onclick="document.getElementById('fileInput').click()">
                    <!-- 显示文件上传提示信息 -->
                    <div class="file-upload-text">
                        点击选择图像文件
                        <br>
                        <small>支持 JPG, PNG, BMP, TIF 格式</small>
                    </div>
                    <!-- 文件选择框 -->
                    <input type="file" id="fileInput" accept=".jpg,.jpeg,.png,.bmp,.tif,.tiff">
                </div>
            </div>

            <!-- 孔洞分析参数设置区域 -->
            <div class="control-section">
                <!-- 显示孔洞分析参数标题 -->
                <h3>孔洞分析参数</h3>
                <!-- 最小面积参数设置 -->
                <div class="param-group">
                    <label>最小面积:</label>
                    <input type="number" id="holeMinArea" value="1" min="1">
                </div>
                <!-- 最大面积参数设置 -->
                <div class="param-group">
                    <label>最大面积:</label>
                    <input type="text" id="holeMaxArea" value="1000" placeholder="数字或inf">
                </div>
                <!-- 阈值参数设置 -->
                <div class="param-group">
                    <label>阈值:</label>
                    <input type="number" id="holeThreshold" value="100" min="0" max="255">
                </div>
                <!-- 孔洞分析按钮，初始禁用 -->
                <button class="btn btn-primary" id="holeAnalysisBtn" disabled>孔洞分析</button>
            </div>

            <!-- 裂缝分析参数设置区域 -->
            <div class="control-section">
                <!-- 显示裂缝分析参数标题 -->
                <h3>裂缝分析参数</h3>
                <!-- 最小面积参数设置 -->
                <div class="param-group">
                    <label>最小面积:</label>
                    <input type="number" id="crackMinArea" value="1000" min="1">
                </div>
                <!-- 最大面积参数设置 -->
                <div class="param-group">
                    <label>最大面积:</label>
                    <input type="text" id="crackMaxArea" value="inf" placeholder="数字或inf">
                </div>
                <!-- 阈值参数设置 -->
                <div class="param-group">
                    <label>阈值:</label>
                    <input type="number" id="crackThreshold" value="100" min="0" max="255">
                </div>
                <!-- 裂缝分析按钮，初始禁用 -->
                <button class="btn btn-success" id="crackAnalysisBtn" disabled>裂缝分析</button>
            </div>

            <!-- 粒度分析按钮区域 -->
            <div class="control-section">
                <!-- 显示粒度分析标题 -->
                <h3>粒度分析</h3>
                <!-- 粒度分析按钮，初始禁用 -->
                <button class="btn btn-warning" id="grainAnalysisBtn" disabled>粒度分析</button>
            </div>

            <!-- 导出分析数据按钮区域 -->
            <div class="control-section">
                <!-- 导出JSON数据按钮，初始禁用 -->
                <button class="btn btn-info" id="exportDataBtn" disabled>导出JSON数据</button>
                <!-- 导出CSV数据按钮，初始禁用 -->
                <button class="btn btn-info" id="exportCsvBtn" disabled>导出CSV数据</button>
            </div>
        </div>

        <!-- 内容区域，包含加载提示、提示框、图像显示区域、分析结果区域和柱状图区域 -->
        <div class="content-area">
            <!-- 加载提示，初始隐藏 -->
            <div id="loading" class="loading">分析中，请稍候...</div>

            <!-- 提示框区域 -->
            <div id="alertArea"></div>
            <!-- 复原图像按钮 -->
            <button class="btn btn-warning" id="resetImageBtn" style="margin-top: 10px;">复原图像</button>
            <!-- 清除绘制按钮 -->
            <button class="btn btn-warning" id="clearDrawingBtn" style="margin-top: 10px; margin-bottom: 20px;">
                清除绘制
            </button>
            <!-- 图像显示区域，初始隐藏 -->
            <div id="imageArea" style="display: none;">
                <!-- 显示分析结果标题 -->
                <h3 style="color: #2c3e50; margin-bottom: 20px;">分析结果</h3>
                <!-- 图像网格区域，用于显示图像 -->
                <div class="image-grid" id="imageGrid">
                    <!-- 图像将通过JavaScript动态添加 -->
                </div>
            </div>

            <!-- 分析结果区域，初始隐藏 -->
            <div id="resultsArea" style="display: none;">
                <!-- 分析结果部分 -->
                <div class="results-section">
                    <!-- 显示分析数据标题 -->
                    <h3>分析数据</h3>
                    <!-- 分析结果列表，将通过JavaScript动态添加 -->
                    <div id="resultsList">
                        <!-- 结果将通过JavaScript动态添加 -->
                    </div>
                </div>
            </div>

            <!-- 柱状图区域，初始隐藏 -->
            <div id="histogramArea" style="display: none;">
                <!-- 柱状图部分 -->
                <div class="histogram-section">
                    <!-- 显示分布图表标题 -->
                    <h3 style="color: #2c3e50; margin-bottom: 15px;">分布图表</h3>
                    <!-- 显示柱状图图片 -->
                    <img id="histogramImg" alt="分布柱状图">
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    // 定义当前文件名
    let currentFilename = null;
    // 定义当前分析类型
    let currentAnalysisType = null;
    // 定义视图模式是否启用
    let isViewEnabled = false;
    // 定义画笔模式是否启用
    let isBrushEnabled = false;
    // 定义画笔颜色
    let brushColor = '#ff0000';
    // 定义画笔大小
    let brushSize = 5;
    // 定义缩放比例
    let scale = 1;
    // 定义X轴偏移量
    let offsetX = 0;
    // 定义Y轴偏移量
    let offsetY = 0;
    // 定义是否正在拖动
    let isDragging = false;
    // 定义拖动开始时的X坐标
    let startX = 0;
    // 定义拖动开始时的Y坐标
    let startY = 0;
    // 定义是否正在绘制
    let isDrawing = false;
    // 定义上次绘制的X坐标
    let lastX = 0;
    // 定义上次绘制的Y坐标
    let lastY = 0;
    // 定义画布数组
    let canvases = [];
    // 定义画布上下文数组
    let ctxs = [];
    // 定义当前操作的图片
    let currentImg = null;
    // 定义当前操作的画布
    let currentCanvas = null;
    // 定义分析数据
    let analysisData = null;

    // 文件上传处理函数
    document.getElementById('fileInput').addEventListener('change', function (e) {
        // 获取选择的文件
        const file = e.target.files[0];
        // 如果没有选择文件，直接返回
        if (!file) return;

        // 创建表单数据对象
        const formData = new FormData();
        // 将文件添加到表单数据中
        formData
            .append('file', file);

        // 显示加载提示
        showLoading(true);
        // 清除之前的分析结果
        clearResults();

        // 发送文件上传请求
        fetch('/upload', {
            method: 'POST',
            body:
            formData
        })
            .then(response => response.json())
            .then(data => {
                // 隐藏加载提示
                showLoading(false);
                if (data.success) {
                    // 保存当前文件名
                    currentFilename
                        = data.filename;
                    // 启用分析按钮
                    enableAnalysisButtons(true);
                    // 显示上传成功提示
                    showAlert('文件上传成功！', 'success');

                    // 显示原始图像
                    showImages({
                        '原始图像': data.image
                    });
                } else {
                    // 显示上传失败提示
                    showAlert(data.error, 'error');
                }
            })
            .catch(error => {
                // 隐藏加载提示
                showLoading(false);
                // 显示上传失败提示
                showAlert('上传失败: ' + error.message, 'error');
            });
    });

    // 孔洞分析按钮点击事件处理函数
    document.getElementById('holeAnalysisBtn').addEventListener('click', function () {
        // 获取孔洞分析参数
        const params = {
            filename: currentFilename,
            min_area: parseInt(document.getElementById('holeMinArea').value),
            max_area: document.getElementById('holeMaxArea').value === 'inf' ? Infinity : parseInt(document.getElementById('holeMaxArea').value),
            threshold: parseInt(document.getElementById('holeThreshold').value)
        };

        // 设置当前分析类型为孔洞分析
        currentAnalysisType
            = 'hole';
        // 执行分析
        performAnalysis('/analyze/holes', params);
    });

    // 裂缝分析按钮点击事件处理函数
    document.getElementById('crackAnalysisBtn').addEventListener('click', function () {
        // 获取裂缝分析参数
        const minArea = document.getElementById('crackMinArea').value;
        const maxArea = document.getElementById('crackMaxArea').value;
        const threshold = document.getElementById('crackThreshold').value;

        // 参数格式校验
        if (!/^\d+$/.test(minArea) || !/^\d+|inf$/.test(maxArea) || !/^\d+$/.test(threshold)) {
            // 显示参数格式错误提示
            showAlert('参数必须为数字或inf（如1000, inf）', 'error');
            return;
        }

        // 构造裂缝分析参数对象
        const params = {
            filename: currentFilename,
            min_area: parseInt(minArea),
            max_area: maxArea === 'inf' ? Infinity : parseInt(maxArea),
            threshold: parseInt(threshold)
        };

        // 输出调试信息
        console.log('[前端] 裂缝分析参数:', params);

        // 设置当前分析类型为裂缝分析
        currentAnalysisType
            = 'crack';
        // 执行分析
        performAnalysis('/analyze/cracks', params);
    });

    // 粒度分析按钮点击事件处理函数
    document.getElementById('grainAnalysisBtn').addEventListener('click', function () {
        // 获取粒度分析参数
        const params = {
            filename:
            currentFilename
        };

        // 设置当前分析类型为粒度分析
        currentAnalysisType
            = 'grain';
        // 执行分析
        performAnalysis('/analyze/grains', params);
    });

    // 参数变化监听，实时启用按钮
    document.querySelectorAll('input').forEach(input => {
        input
            .addEventListener('input', function () {
                // 根据当前文件名是否存在，启用或禁用分析按钮
                enableAnalysisButtons(currentFilename !== null);
            });
    });

    // 执行分析函数
    function performAnalysis(url, params) {
        // 显示加载提示
        showLoading(true);
        // 清除之前的分析结果
        clearResults();

        // 输出调试信息，显示发送的分析请求
        console.log('[前端] 发送分析请求:', url, params);

        // 发送分析请求
        fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(params)
        })
            .then(response => {
                // 输出调试信息，显示收到的响应状态
                console.log('[前端] 收到响应状态:', response.status);

                if (!response.ok) {
                    // 尝试读取错误响应体
                    return response.json().then(errorData => {
                        throw new Error(errorData.error || `HTTP错误: ${response.status}`);
                    }).catch(() => {
                        throw new Error(`HTTP错误: ${response.status}`);
                    });
                }
                return response.json();
            })
            .then(data => {
                // 输出调试信息，显示分析结果
                console.log('[前端] 分析结果:', data);
                // 隐藏加载提示
                showLoading(false);
                if (data.success) {
                    // 保存分析数据
                    analysisData
                        = data.result;
                    // 启用导出JSON数据按钮
                    document.getElementById('exportDataBtn').disabled = false;
                    // 启用导出CSV数据按钮
                    document.getElementById('exportCsvBtn').disabled = false;
                    // 显示分析完成提示
                    showAlert('分析完成！', 'success');
                    // 显示分析结果
                    displayResults(data);
                } else {
                    // 显示分析失败提示
                    showAlert(data.error, 'error');
                }
            })
            .catch(error => {
                // 输出错误信息
                console.error('[前端] 分析请求异常:', error);
                // 隐藏加载提示
                showLoading(false);
                // 显示分析失败提示
                showAlert(`分析失败: ${error.message}`, 'error');
            });
    }

    // 显示结果函数
    function displayResults(data) {
        // 显示图像
        if (data.images) {
            // 定义图像标签映射
            const imageLabels = {
                original: '原始图像',
                gray: '灰度图',
                binary: '二值图',
                marked: '标记图',
                result: '结果图'
            };

            // 构造图像对象
            const images = {};
            for (const [key, value] of Object.entries(data.images)) {
                if (value) {
                    images
                        [imageLabels[key] || key] = value;
                }
            }
            // 显示图像
            showImages(images);
        }

        // 显示分析结果
        if (data.result) {
            // 显示分析结果
            showResults(data.result, currentAnalysisType);
        }

        // 显示柱状图
        if (data.histogram) {
            // 显示柱状图
            showHistogram(data.histogram);
        }
    }

    // 显示图像并添加绘图画布函数
    function showImages(images) {
        // 获取图像网格元素
        const imageGrid = document.getElementById('imageGrid');
        // 清空图像网格元素内容
        imageGrid
            .innerHTML = '';

        // 清除之前的画布
        canvases
            = [];
        ctxs
            = [];

        // 遍历图像对象
        for (const [title, base64] of Object.entries(images)) {
            // 创建画布容器元素
            const canvasContainer = document.createElement('div');
            canvasContainer
                .className = 'canvas-container';

            // 创建图像卡片元素
            const imageCard = document.createElement('div');
            imageCard
                .className = 'image-card';
            imageCard
                .innerHTML = `
                    <h4>${title}</h4>
                    <div class="canvas-container">
                        <img src="data:image/png;base64,${base64}" alt="${title}" class="image-element">
                        <canvas class="drawing-canvas"></canvas>
                    </div>
                `;

            // 获取canvas元素并初始化
            const canvas = imageCard.querySelector('.drawing-canvas');
            const ctx = canvas.getContext('2d');
            canvases
                .push(canvas);
            ctxs
                .push(ctx);

            // 设置canvas大小与图片一致
            const img = imageCard.querySelector('img');
            img
                .onload = function () {
                canvas
                    .width = img.width;
                canvas
                    .height = img.height;
                canvas
                    .style.width = img.style.width;
                canvas
                    .style.height = img.style.height;
            };

            // 添加鼠标事件监听
            setupCanvasEvents(canvas, ctx);

            // 将图像卡片添加到图像网格中
            imageGrid
                .appendChild(imageCard);
        }

        // 显示图像区域
        document.getElementById('imageArea').style.display = 'block';
    }

    // 设置画布事件监听函数
    function setupCanvasEvents(canvas, ctx) {
        // 鼠标按下开始绘图
        canvas
            .addEventListener('mousedown', function (e) {
                if (isBrushEnabled && !isViewEnabled) {
                    isDrawing
                        = true;
                    const rect = canvas.getBoundingClientRect();
                    // 考虑缩放和偏移
                    lastX
                        = (e.clientX - rect.left - offsetX) / scale;
                    lastY
                        = (e.clientY - rect.top - offsetY) / scale;

                    // 开始绘制点
                    ctx
                        .beginPath();
                    ctx
                        .arc(lastX, lastY, brushSize, 0, Math.PI * 2);
                    ctx
                        .fillStyle = brushColor;
                    ctx
                        .fill();
                }
            });

        // 鼠标移动绘制线条
        canvas
            .addEventListener('mousemove', function (e) {
                if (isDrawing && isBrushEnabled && !isViewEnabled) {
                    const rect = canvas.getBoundingClientRect();
                    // 考虑缩放和偏移
                    const x = (e.clientX - rect.left - offsetX) / scale;
                    const y = (e.clientY - rect.top - offsetY) / scale;

                    // 绘制线条
                    ctx
                        .beginPath();
                    ctx
                        .moveTo(lastX, lastY);
                    ctx
                        .lineTo(x, y);
                    ctx
                        .strokeStyle = brushColor;
                    ctx
                        .lineWidth = brushSize * 2; // 画笔粗细
                    ctx
                        .lineCap = 'round';
                    ctx
                        .lineJoin = 'round';
                    ctx
                        .stroke();

                    lastX
                        = x;
                    lastY
                        = y;
                }
            });

        // 鼠标松开结束绘图
        canvas
            .addEventListener('mouseup', function () {
                isDrawing
                    = false;
            });

        // 鼠标离开画布结束绘图
        canvas
            .addEventListener('mouseout', function () {
                isDrawing
                    = false;
            });

        // 视图缩放和移动事件
        canvas
            .addEventListener('wheel', function (e) {
                if (isViewEnabled && !isBrushEnabled) {
                    e
                        .preventDefault(); // 阻止页面滚动

                    const rect = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    // 计算缩放因子
                    const delta = e.deltaY > 0 ? 0.9 : 1.1;
                    const oldScale = scale;
                    scale
                        *= delta;

                    // 限制缩放范围
                    scale
                        = Math.max(0.5, Math.min(5, scale));

                    // 调整偏移量以实现以鼠标位置为中心缩放
                    offsetX
                        += mouseX / oldScale - mouseX / scale;
                    offsetY
                        += mouseY / oldScale - mouseY / scale;

                    // 应用变换到图像
                    const img = canvas.previousElementSibling;
                    if (img) {
                        img
                            .style.transform = `scale(${scale}) translate(${offsetX}px, ${offsetY}px)`;
                        img
                            .style.transformOrigin = '0 0';
                    }

                    // 应用变换到画布
                    canvas
                        .style.transform = `scale(${scale}) translate(${offsetX}px, ${offsetY}px)`;
                    canvas
                        .style.transformOrigin = '0 0';
                }
            });

        // 视图移动事件
        canvas
            .addEventListener('mousedown', function (e) {
                if (isViewEnabled && !isBrushEnabled && e.button === 0) { // 左键
                    isDragging
                        = true;
                    startX
                        = e.clientX;
                    startY
                        = e.clientY;
                    const img = canvas.previousElementSibling;
                    // 记录当前操作的图片和画布
                    currentImg
                        = img;
                    currentCanvas
                        = canvas;
                }
            });
    }

    // 鼠标移动事件处理函数
    document.addEventListener('mousemove', function (e) {
        if (isDragging && isViewEnabled && !isBrushEnabled && currentImg && currentCanvas) {
            const dx = (e.clientX - startX) / scale;
            const dy = (e.clientY - startY) / scale;
            offsetX
                += dx;
            offsetY
                += dy;
            startX
                = e.clientX;
            startY
                = e.clientY;

            // 应用变换到图像
            currentImg
                .style.transform = `scale(${scale}) translate(${offsetX}px, ${offsetY}px)`;
            currentImg
                .style.transformOrigin = '0 0';

            // 应用变换到画布
            currentCanvas
                .style.transform = `scale(${scale}) translate(${offsetX}px, ${offsetY}px)`;
            currentCanvas
                .style.transformOrigin = '0 0';
        }
    });

    // 鼠标松开事件处理函数
    document.addEventListener('mouseup', function () {
        isDragging
            = false;
        currentImg
            = null;
        currentCanvas
            = null;
    });

    // 显示分析结果函数
    function showResults(result, type) {
        // 获取结果列表元素
        const resultsList = document.getElementById('resultsList');
        // 清空结果列表元素内容
        resultsList
            .innerHTML = '';

        if (type === 'hole') {
            // 定义孔洞分析结果项
            const items = [
                ['孔洞数量', result['孔洞数量']],
                ['总面积', result['总面积'].toFixed(2) + ' 像素'],
                ['平均面积', result['平均面积'].toFixed(2) + ' 像素'],
                ['平均圆形度', result['平均圆形度'].toFixed(2)]
            ];
            // 遍历结果项，添加到结果列表中
            items
                .forEach(([label, value]) => addResultItem(resultsList, label, value));
        } else if (type === 'crack') {
            // 调试信息：输出完整的result对象到控制台
            console.log("裂缝分析结果对象:", result);

            // 尝试从多种可能的格式中提取特征
            let features = {};

            // 1. 检查是否有"特征"字段
            if (result.特征 && Object.keys(result.特征).length > 0) {
                features
                    = result.特征;
                console.log("使用result.特征字段");
            }
            // 2. 检查是否有"裂缝"数组
            else if (result.裂缝 && Array.isArray(result.裂缝) && result.裂缝.length > 0) {
                console.log("使用result.裂缝数组");
                const cracks = result.裂缝;
                const totalArea = cracks.reduce((sum, crack) => sum + (crack.面积 || 0), 0);
                features
                    = {
                    '数量': cracks.length,
                    '总面积': totalArea,
                    '平均面积': cracks.length > 0 ? totalArea / cracks.length : 0
                };
                // 查找最大裂缝
                const maxCrack = cracks.reduce((max, crack) => {
                    return (crack.面积 || 0) > (max.面积 || 0) ? crack : max;
                }, {面积: 0});
                if (maxCrack.面积 > 0) {
                    features
                        ['最大裂缝方向'] = maxCrack.方向 || '未知';
                    features
                        ['最大裂缝长度'] = maxCrack.长度 || 0;
                    features
                        ['最大裂缝最大宽度'] = maxCrack.最大宽度 || 0;
                    features
                        ['最大裂缝最小宽度'] = maxCrack.最小宽度 || 0;
                }
            }
            // 3. 检查是否直接包含裂缝特征
            else if (result.数量 !== undefined || result.裂缝数量 !== undefined) {
                console.log("使用直接的裂缝特征字段");
                features
                    = {
                    '数量': result.数量 || result.裂缝数量 || 0,
                    '总面积': result.总面积 || result.裂缝总面积 || 0,
                    '平均面积': (result.数量 || result.裂缝数量 || 1) > 0 ?
                        ((result.总面积 || result.裂缝总面积 || 0) / (result.数量 || result.裂缝数量 || 1)) : 0,
                    '最大裂缝方向': result.最大裂缝方向 || '未知',
                    '最大裂缝长度': result.最大裂缝长度 || 0,
                    '最大裂缝最大宽度': result.最大裂缝最大宽度 || 0,
                    '最大裂缝最小宽度': result.最大裂缝最小宽度 || 0
                };
            }
            // 4. 默认空结果
            else {
                console.log("使用默认空结果");
                features
                    = {
                    '数量': 0,
                    '总面积': 0,
                    '平均面积': 0,
                    '最大裂缝方向': '无',
                    '最大裂缝长度': 0,
                    '最大裂缝最大宽度': 0,
                    '最大裂缝最小宽度': 0
                };
            }

            // 格式化结果
            const items = [
                ['裂缝数量', features['数量']],
                ['总面积', features['总面积'].toFixed(2) + ' 像素'],
                ['平均面积', features['平均面积'].toFixed(2) + ' 像素'],
                ['最大裂缝方向', features['最大裂缝方向']],
                ['最大裂缝长度', features['最大裂缝长度'].toFixed(2) + ' 像素'],
                ['最大裂缝最大宽度', features['最大裂缝最大宽度'].toFixed(2) + ' 像素'],
                ['最大裂缝最小宽度', features['最大裂缝最小宽度'].toFixed(2) + ' 像素']
            ];
            // 遍历结果项，添加到结果列表中
            items
                .forEach(([label, value]) => addResultItem(resultsList, label, value));

            // 显示检测结果提示
            const count = features['数量'] || 0;
            addResultItem(resultsList, '检测结果', count > 0 ? `检测到 ${count} 条裂缝` : '未检测到符合条件的裂缝');
        } else if (type === 'grain') {
            // 定义粒度分析结果项
            const items = [
                ['粒子数量', result['粒子数量']],
                ['平均面积', result['平均面积'].toFixed(2) + ' 像素']
            ];
            // 遍历结果项，添加到结果列表中
            items
                .forEach(([label, value]) => addResultItem(resultsList, label, value));
        }

        // 显示结果区域
        document.getElementById('resultsArea').style.display = 'block';
    }

    // 添加结果项函数
    function addResultItem(container, label, value) {
        // 创建结果项元素
        const item = document.createElement('div');
        item
            .className = 'result-item';
        item
            .innerHTML = `
                <span class="result-label">${label}:</span>
                <span class="result-value">${value}</span>
            `;
        // 将结果项添加到容器中
        container
            .appendChild(item);
    }

    // 显示柱状图函数
    function showHistogram(base64) {
        // 设置柱状图图片的src属性
        document.getElementById('histogramImg').src = 'data:image/png;base64,' + base64;
        // 显示柱状图区域
        document.getElementById('histogramArea').style.display = 'block';
    }

    // 显示加载提示函数
    function showLoading(show) {
        // 根据show参数显示或隐藏加载提示
        document.getElementById('loading').style.display = show ? 'block' : 'none';
    }

    // 启用分析按钮函数
    function enableAnalysisButtons(enable) {
        // 启用或禁用孔洞分析按钮
        document.getElementById('holeAnalysisBtn').disabled = !enable;
        // 启用或禁用裂缝分析按钮
        document.getElementById('crackAnalysisBtn').disabled = !enable;
        // 启用或禁用粒度分析按钮
        document.getElementById('grainAnalysisBtn').disabled = !enable;
        // 启用或禁用导出JSON数据按钮
        document.getElementById('exportDataBtn').disabled = !enable || !analysisData;
        // 启用或禁用导出CSV数据按钮
        document.getElementById('exportCsvBtn').disabled = !enable || !analysisData;
    }

    // 清除结果函数
    function clearResults() {
        // 隐藏图像区域
        document.getElementById('imageArea').style.display = 'none';
        // 隐藏结果区域
        document.getElementById('resultsArea').style.display = 'none';
        // 隐藏柱状图区域
        document.getElementById('histogramArea').style.display = 'none';
        // 禁用导出JSON数据按钮
        document.getElementById('exportDataBtn').disabled = true;
        // 禁用导出CSV数据按钮
        document.getElementById('exportCsvBtn').disabled = true;
        // 清空分析数据
        analysisData
            = null;
    }

    // 显示提示框函数
    function showAlert(message, type) {
        // 获取提示框区域元素
        const alertArea = document.getElementById('alertArea');
        // 根据type参数设置提示框类名
        const alertClass = type === 'success' ? 'alert-success' : 'alert-error';

        // 设置提示框内容
        alertArea
            .innerHTML = `<div class="alert ${alertClass}">${message}</div>`;

        // 自动隐藏提示信息
        setTimeout(() => {
            alertArea
                .innerHTML = '';
        }, 5000);
    }

         // 视图开关事件处理
        document.getElementById('viewSwitch').addEventListener('change', function () {
            // 更新视图模式状态
            isViewEnabled = this.checked;
            if (isViewEnabled) {
                // 启用视图模式时禁用画笔模式
                isBrushEnabled = false;
                document.getElementById('brushSwitch').checked = false;
                // 更改鼠标光标样式为移动图标
                document.body.style.cursor = 'move';
            } else {
                // 恢复默认鼠标光标样式
                document.body.style.cursor = 'default';
            }
        });

        // 画笔开关事件处理
        document.getElementById('brushSwitch').addEventListener('change', function () {
            // 更新画笔模式状态
            isBrushEnabled = this.checked;
            if (isBrushEnabled) {
                // 启用画笔模式时禁用视图模式
                isViewEnabled = false;
                document.getElementById('viewSwitch').checked = false;
                // 更改鼠标光标样式为十字线
                document.body.style.cursor = 'crosshair';
            } else {
                // 恢复默认鼠标光标样式
                document.body.style.cursor = 'default';
            }
        });

        // 画笔颜色和大小变化事件处理
        document.getElementById('brushColor').addEventListener('input', function () {
            // 更新画笔颜色
            brushColor = this.value;
        });

        document.getElementById('brushSize').addEventListener('input', function () {
            // 更新画笔大小
            brushSize = parseInt(this.value);
        });

        // 重置画布
        function resetCanvas() {
            // 清除所有画布上的绘制内容
            ctxs.forEach(ctx => {
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            });
        }

        // 添加清除按钮点击事件
        const clearDrawingBtn = document.getElementById('clearDrawingBtn');
        clearDrawingBtn.addEventListener('click', resetCanvas);

        // 重置图像位置和缩放
        function resetImage() {
            canvases.forEach((canvas, index) => {
                const img = canvas.previousElementSibling;
                // 重置缩放比例和偏移量
                scale = 1;
                offsetX = 0;
                offsetY = 0;
                // 应用重置后的变换
                img.style.transform = `scale(${scale}) translate(${offsetX}px, ${offsetY}px)`;
                img.style.transformOrigin = '0 0';
                canvas.style.transform = `scale(${scale}) translate(${offsetX}px, ${offsetY}px)`;
                canvas.style.transformOrigin = '0 0';
            });
        }

        // 添加复原图像按钮点击事件
        const resetImageBtn = document.getElementById('resetImageBtn');
        resetImageBtn.addEventListener('click', resetImage);

        // 导出分析数据为JSON
        document.getElementById('exportDataBtn').addEventListener('click', function () {
            if (analysisData) {
                // 将分析数据转换为格式化的JSON字符串
                const jsonData = JSON.stringify(analysisData, null, 2);
                // 创建Blob对象
                const blob = new Blob([jsonData], {type: 'application/json'});
                // 创建临时URL
                const url = URL.createObjectURL(blob);
                // 创建下载链接
                const a = document.createElement('a');
                a.href = url;
                // 设置文件名，包含分析类型和日期
                a.download = `岩心分析_${currentAnalysisType}_${new Date().toISOString().slice(0, 10)}.json`;
                // 触发下载
                a.click();
                // 释放临时URL
                URL.revokeObjectURL(url);
                // 显示成功提示
                showAlert('JSON数据导出成功！', 'success');
            }
        });

        // 导出分析数据为CSV
        document.getElementById('exportCsvBtn').addEventListener('click', function () {
            if (analysisData) {
                try {
                    // 根据分析类型生成不同的 CSV 数据
                    let csvContent = '\uFEFF属性,值\n';

                    if (currentAnalysisType === 'hole') {
                        // 孔洞分析数据
                        csvContent += `孔洞数量,${analysisData['孔洞数量'] || 0}\n`;
                        csvContent += `总面积(像素),${analysisData['总面积'] || 0}\n`;
                        csvContent += `平均面积(像素),${analysisData['平均面积'] || 0}\n`;
                        csvContent += `平均圆形度,${analysisData['平均圆形度'] || 0}\n`;

                        // 输出每个孔洞的面积
                        const areaList = analysisData['面积列表'] || [];
                        areaList.forEach((area, index) => {
                            csvContent += `孔洞${index + 1}面积(像素),${area}\n`;
                        });
                    } else if (currentAnalysisType === 'crack') {
                        // 裂缝分析数据
                        if (analysisData.裂缝 && Array.isArray(analysisData.裂缝) && analysisData.裂缝.length > 0) {
                            // 导出详细的裂缝数据
                            analysisData.裂缝.forEach((crack, index) => {
                                csvContent += `裂缝${index + 1}ID,${index + 1}\n`;
                                csvContent += `裂缝${index + 1}面积(像素),${crack.面积 || 0}\n`;
                                csvContent += `裂缝${index + 1}方向,${crack.方向 || '未知'}\n`;
                                csvContent += `裂缝${index + 1}长度(像素),${crack.长度 || 0}\n`;
                                csvContent += `裂缝${index + 1}最大宽度(像素),${crack.最大宽度 || 0}\n`;
                                csvContent += `裂缝${index + 1}最小宽度(像素),${crack.最小宽度 || 0}\n`;
                            });
                        } else {
                            // 导出汇总数据
                            csvContent += `裂缝数量,${analysisData.数量 || analysisData.裂缝数量 || 0}\n`;
                            csvContent += `总面积(像素),${analysisData.总面积 || analysisData.裂缝总面积 || 0}\n`;
                            csvContent += `平均面积(像素),${analysisData.平均面积 || 0}\n`;
                            csvContent += `最大裂缝方向,${analysisData.最大裂缝方向 || '未知'}\n`;
                            csvContent += `最大裂缝长度(像素),${analysisData.最大裂缝长度 || 0}\n`;
                            csvContent += `最大裂缝最大宽度(像素),${analysisData.最大裂缝最大宽度 || 0}\n`;
                            csvContent += `最大裂缝最小宽度(像素),${analysisData.最大裂缝最小宽度 || 0}\n`;
                        }
                    } else if (currentAnalysisType === 'grain') {
                        // 粒度分析数据
                        csvContent += `粒子数量,${analysisData['粒子数量'] || 0}\n`;
                        csvContent += `平均面积(像素),${analysisData['平均面积'] || 0}\n`;

                        // 输出每个粒子的面积
                        const areaList = analysisData['面积列表'] || [];
                        areaList.forEach((area, index) => {
                            csvContent += `粒子${index + 1}面积(像素),${area}\n`;
                        });
                    }

                    // 创建Blob对象并下载
                    const blob = new Blob([csvContent], {type: 'text/csv;charset=utf-8;'});
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `岩心分析_${currentAnalysisType}_${new Date().toISOString().slice(0, 10)}.csv`;
                    a.click();
                    URL.revokeObjectURL(url);
                    showAlert('CSV数据导出成功！', 'success');
                } catch (error) {
                    console.error('CSV导出错误:', error);
                    showAlert('CSV数据导出失败: ' + error.message, 'error');
                }
            }
        });
    </script>
</body>
</html>